'''
[编程题] 洗牌
时间限制：1秒
空间限制：32768K
洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，
从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，
左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。
接着就开始洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，
接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。
接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，
左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。
把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 
现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。 
输入描述:
第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，
接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。


输出描述:
对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。

输入例子1:
3 3 1 1 2 3 4 5 6 3 2 1 2 3 4 5 6 2 2 1 1 1 1

输出例子1:
1 4 2 5 3 6 1 5 4 3 2 6 1 1 1 1
'''

'''
解题思路：散列表
  这道题是有道的内推题，所以考点和字典数据集有关，这道题目考的是散列表，如果把新牌放入数组一中，
  洗过的牌放入数组二中，那么数组一个数组二之间各个元素的位置存在一定的映射关系。即：
  数组一中在j号位置的元素在数组二中的位置是index = (2j % len(数组二))，
  如果该位置已经有元素，则index自动加一，搜索下一个位置，直到找到空位置。
  这道题目的数据比较简单，其实没必要用散列表做，依靠找规律或者切片就能把做出来，
  很多人用的是切片，使用[::2]和[1::2]找出数列二中的所有偶数位和奇数位，把数列一的前n个数和后n个数放进去即可。
  但我个人觉得python切片的效率不高，于是换了找规律的方法，如果 2j < 2n ， 则index=2j，否则index = index % (2*n) + 1，
  如此循环k次。使用这种方法每次都直接找到某张牌在k次洗牌后的位置，避免了大量的切片操作，
  也避免了大量在数组中寻找元素并赋值的操作。
  （Ps，这倒题目的输入和输出比较坑爹）
'''

'''
代码运行结果：
答案正确:恭喜！您提交的程序通过了所有的测试用例
'''

T = int(input())

array_list = []
n, k = [int(each) for each in input().split()]
for x in range(T):
    digs = [int(each) for each in input().split()]
    array = digs[0:2*n]
    results = [None] * (2 * n)
    for j in range(2*n):
        index = j
        for i in range(k):
            index = 2 * index
            if index >= 2 * n:
                index = index % (2*n) + 1
        results[index] = array[j]
    n, k = digs[-2:]
    results = map(str, results)
    print(' '.join(results))
